# Java 注解、AOP、切面与反射详细教程

## 一、注解 (Annotations)

### 1. 注解概述
注解是一种元数据，为代码提供信息，但不直接影响代码执行

### 2. 内置注解
```java
@Override   // 表示方法重写父类方法
@Deprecated  // 表示已过时的方法或类
@SuppressWarnings("unchecked") // 抑制编译器警告
@FunctionalInterface // 表示函数式接口
```

### 3. 元注解（用于定义注解的注解）
```java
@Target(ElementType.METHOD) // 指定注解使用目标
@Retention(RetentionPolicy.RUNTIME) // 指定注解保留策略
@Documented // 包含在JavaDoc中
@Inherited // 允许子类继承
@Repeatable // 可重复使用
```

### 4. 自定义注解
```java
// 定义注解
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface CustomAnnotation {
    String value() default "default"; // 属性定义
    int count() default 0;
    String[] tags() default {};
}

// 使用注解
@CustomAnnotation(value = "test", count = 5, tags = {"a", "b"})
public class MyClass {
    @CustomAnnotation("method")
    public void myMethod() {}
}
```

## 二、反射 (Reflection)

### 1. 获取Class对象的三种方式
```java
// 1. 通过类名.class
Class<String> stringClass = String.class;

// 2. 通过对象.getClass()
String str = "hello";
Class<?> strClass = str.getClass();

// 3. 通过Class.forName()
try {
    Class<?> clazz = Class.forName("java.lang.String");
} catch (ClassNotFoundException e) {
    e.printStackTrace();
}
```

### 2. 获取类信息
```java
Class<?> clazz = MyClass.class;

// 获取类名
String className = clazz.getName();
String simpleName = clazz.getSimpleName();

// 获取修饰符
int modifiers = clazz.getModifiers();
boolean isPublic = Modifier.isPublic(modifiers);

// 获取包信息
Package pkg = clazz.getPackage();

// 获取父类
Class<?> superClass = clazz.getSuperclass();

// 获取实现的接口
Class<?>[] interfaces = clazz.getInterfaces();
```

### 3. 操作字段
```java
// 获取所有字段（包括私有）
Field[] fields = clazz.getDeclaredFields();

// 获取指定字段
try {
    Field field = clazz.getDeclaredField("fieldName");
    
    // 设置可访问（即使是私有字段）
    field.setAccessible(true);
    
    // 获取字段值
    Object value = field.get(objectInstance);
    
    // 设置字段值
    field.set(objectInstance, newValue);
    
} catch (NoSuchFieldException | IllegalAccessException e) {
    e.printStackTrace();
}
```

### 4. 操作方法
```java
// 获取所有方法
Method[] methods = clazz.getDeclaredMethods();

// 获取指定方法
try {
    Method method = clazz.getDeclaredMethod("methodName", parameterTypes);
    
    // 设置可访问
    method.setAccessible(true);
    
    // 调用方法
    Object result = method.invoke(objectInstance, args);
    
} catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
    e.printStackTrace();
}
```

### 5. 操作构造方法
```java
// 获取构造方法
Constructor<?>[] constructors = clazz.getDeclaredConstructors();

try {
    // 获取指定构造方法
    Constructor<?> constructor = clazz.getDeclaredConstructor(parameterTypes);
    constructor.setAccessible(true);
    
    // 创建新实例
    Object newInstance = constructor.newInstance(args);
    
} catch (Exception e) {
    e.printStackTrace();
}
```

### 6. 读取注解信息
```java
// 检查类是否有某个注解
if (clazz.isAnnotationPresent(CustomAnnotation.class)) {
    CustomAnnotation annotation = clazz.getAnnotation(CustomAnnotation.class);
    String value = annotation.value();
}

// 获取方法上的注解
Method method = clazz.getDeclaredMethod("methodName");
if (method.isAnnotationPresent(CustomAnnotation.class)) {
    CustomAnnotation annotation = method.getAnnotation(CustomAnnotation.class);
}
```

## 三、AOP (Aspect-Oriented Programming)

### 1. AOP核心概念
- **Aspect（切面）**：横切关注点的模块化
- **Join Point（连接点）**：程序执行过程中的特定点
- **Pointcut（切点）**：匹配连接点的表达式
- **Advice（通知）**：在切点执行的动作
- **Weaving（织入）**：将切面应用到目标对象的过程

### 2. Spring AOP 配置
```xml
<!-- Maven 依赖 -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-aop</artifactId>
    <version>5.3.0</version>
</dependency>
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.9.6</version>
</dependency>
```

### 3. 切点表达式
```java
// 常用表达式示例
@Pointcut("execution(* com.example.service.*.*(..))") // 包下所有方法
@Pointcut("execution(* *..find*(..))") // 所有find开头的方法
@Pointcut("within(com.example.service..*)") // service包及子包
@Pointcut("this(com.example.service.UserService)") // 实现指定接口
@Pointcut("target(com.example.service.UserService)") // 目标对象类型
@Pointcut("@within(org.springframework.stereotype.Service)") // 有@Service注解的类
@Pointcut("@annotation(com.example.annotation.Log)") // 有@Log注解的方法
@Pointcut("args(java.lang.String, ..)") // 第一个参数为String的方法
@Pointcut("bean(userService)") // 指定bean名称
```

### 4. 通知类型
```java
@Aspect
@Component
public class LoggingAspect {
    
    // 前置通知
    @Before("execution(* com.example.service.*.*(..))")
    public void beforeAdvice(JoinPoint joinPoint) {
        System.out.println("Before method: " + joinPoint.getSignature().getName());
    }
    
    // 后置通知（无论是否异常都执行）
    @After("execution(* com.example.service.*.*(..))")
    public void afterAdvice(JoinPoint joinPoint) {
        System.out.println("After method: " + joinPoint.getSignature().getName());
    }
    
    // 返回后通知
    @AfterReturning(
        pointcut = "execution(* com.example.service.*.*(..))",
        returning = "result"
    )
    public void afterReturningAdvice(JoinPoint joinPoint, Object result) {
        System.out.println("Method returned: " + result);
    }
    
    // 异常通知
    @AfterThrowing(
        pointcut = "execution(* com.example.service.*.*(..))",
        throwing = "ex"
    )
    public void afterThrowingAdvice(JoinPoint joinPoint, Exception ex) {
        System.out.println("Exception in method: " + ex.getMessage());
    }
    
    // 环绕通知（最强大）
    @Around("execution(* com.example.service.*.*(..))")
    public Object aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable {
        // 方法执行前
        System.out.println("Before method: " + joinPoint.getSignature().getName());
        
        long start = System.currentTimeMillis();
        Object result = joinPoint.proceed(); // 执行目标方法
        long time = System.currentTimeMillis() - start;
        
        // 方法执行后
        System.out.println("Method executed in " + time + "ms");
        return result;
    }
}
```

### 5. 获取方法信息
```java
@Aspect
@Component
public class InfoAspect {
    
    @Before("execution(* com.example.service.*.*(..))")
    public void logMethodInfo(JoinPoint joinPoint) {
        // 获取方法签名
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        
        // 获取方法信息
        String methodName = signature.getName();
        String className = signature.getDeclaringTypeName();
        String[] paramNames = signature.getParameterNames();
        Class<?>[] paramTypes = signature.getParameterTypes();
        Class<?> returnType = signature.getReturnType();
        
        // 获取参数值
        Object[] args = joinPoint.getArgs();
        
        // 获取注解
        Method method = signature.getMethod();
        if (method.isAnnotationPresent(Transactional.class)) {
            Transactional transactional = method.getAnnotation(Transactional.class);
            // 处理注解信息
        }
    }
}
```

## 四、综合实战案例

### 1. 自定义注解 + AOP + 反射实现日志记录
```java
// 1. 定义日志注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Loggable {
    String value() default "";
    boolean trackTime() default false;
}

// 2. 实现切面
@Aspect
@Component
public class LoggingAspect {
    
    private static final Logger logger = LoggerFactory.getLogger(LoggingAspect.class);
    
    @Around("@annotation(loggable)")
    public Object logMethod(ProceedingJoinPoint joinPoint, Loggable loggable) throws Throwable {
        String methodName = joinPoint.getSignature().getName();
        String className = joinPoint.getTarget().getClass().getSimpleName();
        
        // 记录方法开始
        logger.info("开始执行 {}.{}", className, methodName);
        
        long startTime = System.currentTimeMillis();
        Object result;
        
        try {
            result = joinPoint.proceed(); // 执行原方法
            
            // 记录方法结束
            long executionTime = System.currentTimeMillis() - startTime;
            logger.info("完成执行 {}.{} - 耗时: {}ms", className, methodName, executionTime);
            
            if (loggable.trackTime() && executionTime > 1000) {
                logger.warn("方法执行时间过长: {}ms", executionTime);
            }
            
        } catch (Exception e) {
            logger.error("执行 {}.{} 时发生异常: {}", className, methodName, e.getMessage());
            throw e;
        }
        
        return result;
    }
}

// 3. 使用注解
@Service
public class UserService {
    
    @Loggable(value = "创建用户", trackTime = true)
    public User createUser(String name, String email) {
        // 业务逻辑
        return new User(name, email);
    }
    
    @Loggable("查询用户")
    public User getUserById(Long id) {
        // 业务逻辑
        return userRepository.findById(id);
    }
}
```

### 2. 自动重试机制
```java
// 重试注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Retryable {
    int maxAttempts() default 3;
    long delay() default 1000;
    Class<? extends Throwable>[] retryOn() default {Exception.class};
}

// 重试切面
@Aspect
@Component
public class RetryAspect {
    
    @Around("@annotation(retryable)")
    public Object retryOperation(ProceedingJoinPoint joinPoint, Retryable retryable) throws Throwable {
        int attempts = 0;
        int maxAttempts = retryable.maxAttempts();
        long delay = retryable.delay();
        Class<? extends Throwable>[] retryOn = retryable.retryOn();
        
        while (attempts < maxAttempts) {
            try {
                attempts++;
                return joinPoint.proceed(); // 尝试执行
                
            } catch (Throwable e) {
                // 检查异常类型是否应该重试
                boolean shouldRetry = false;
                for (Class<? extends Throwable> exceptionType : retryOn) {
                    if (exceptionType.isInstance(e)) {
                        shouldRetry = true;
                        break;
                    }
                }
                
                if (!shouldRetry || attempts >= maxAttempts) {
                    throw e; // 不重试或已达到最大重试次数
                }
                
                // 等待后重试
                Thread.sleep(delay);
            }
        }
        
        throw new RuntimeException("Max retry attempts exceeded");
    }
}
```

## 五、最佳实践和注意事项

### 1. 性能考虑
- 反射操作比直接调用慢，应避免在性能关键路径中过度使用
- AOP会创建代理对象，增加调用开销
- 缓存反射结果以提高性能

### 2. 设计原则
- 保持切面职责单一，一个切面只做一件事
- 避免在切面中包含复杂业务逻辑
- 谨慎使用环绕通知，确保调用proceed()方法

### 3. 调试技巧
- 使用`JoinPoint`获取详细的执行信息
- 在开发环境开启AOP调试日志
- 注意代理对象的类型（JDK动态代理 vs CGLIB代理）

### 4. 常见陷阱
- 自调用问题（同一个类中的方法互相调用不会触发AOP）
- 异常处理要小心，避免吞掉异常
- 注意执行顺序，多个切面作用于同一个方法时


# 关于精确匹配特定名称的注解

要在 Spring AOP 中精确匹配名为 `Log` 的注解（而不是其他可能名称相似的注解），有几种方法可以实现。让我详细解释这些方法。

## 方法 1：使用完全限定名（推荐）

最明确的方式是在切点表达式中使用注解的完全限定名（包括包名）：

```java
@Before("@annotation(com.yourpackage.Log) && args(..)")
public void logBefore(JoinPoint joinPoint) {
    // 通过反射获取注解
    MethodSignature signature = (MethodSignature) joinPoint.getSignature();
    Method method = signature.getMethod();
    Log logAnnotation = method.getAnnotation(Log.class);
    
    // 使用注解
    String value = logAnnotation.value();
    // 其他操作...
}
```

或者如果你仍然想使用参数绑定：

```java
@Before("@annotation(com.yourpackage.Log) && @annotation(logAnnotation)")
public void logBefore(JoinPoint joinPoint, Log logAnnotation) {
    // 直接使用 logAnnotation 参数
    String value = logAnnotation.value();
    // 其他操作...
}
```

## 方法 2：使用参数类型约束

Spring AOP 实际上已经通过方法参数的类型来约束注解类型了。所以即使你使用通用的参数名，只要参数类型是 `Log`，它就只会匹配 `Log` 注解：

```java
// 这实际上已经只匹配 Log 注解了，因为参数类型是 Log
@Before("@annotation(logAnnotation)")
public void logBefore(JoinPoint joinPoint, Log logAnnotation) {
    // 这个 logAnnotation 参数只会是 Log 类型的注解实例
    String value = logAnnotation.value();
    // 其他操作...
}
```

## 方法 3：创建特定的切点表达式

你可以创建一个专门的切点表达式来匹配 `Log` 注解：

```java
@Pointcut("@annotation(com.yourpackage.Log)")
public void logAnnotationPointcut() {}

@Before("logAnnotationPointcut()")
public void logBefore(JoinPoint joinPoint) {
    MethodSignature signature = (MethodSignature) joinPoint.getSignature();
    Method method = signature.getMethod();
    Log logAnnotation = method.getAnnotation(Log.class);
    
    // 使用注解
    String value = logAnnotation.value();
    // 其他操作...
}
```

或者结合参数绑定：

```java
@Pointcut("@annotation(logAnnotation)")
public void logAnnotationPointcut(Log logAnnotation) {}

@Before("logAnnotationPointcut(logAnnotation)")
public void logBefore(JoinPoint joinPoint, Log logAnnotation) {
    // 直接使用 logAnnotation 参数
    String value = logAnnotation.value();
    // 其他操作...
}
```

## 方法 4：确保注解名称唯一性

最好的实践是确保你的注解名称在项目中是唯一的，或者使用完整的包路径来引用注解。例如：

```java
package com.yourcompany.logging;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface Log {
    String value() default "";
}
```

然后在切面中：

```java
package com.yourcompany.aspect;

import com.yourcompany.logging.Log;

@Aspect
@Component
public class LogAspect {
    
    @Before("@annotation(com.yourcompany.logging.Log) && @annotation(logAnnotation)")
    public void logBefore(JoinPoint joinPoint, Log logAnnotation) {
        // 这只会匹配 com.yourcompany.logging.Log 注解
        String value = logAnnotation.value();
        // 其他操作...
    }
}
```

## 为什么这些方法有效

1. **类型安全**：Java 是强类型语言，方法参数的类型 `Log` 确保了只有 `Log` 注解会被绑定
2. **完全限定名**：使用完整的包名+类名可以避免与其他同名注解的冲突
3. **Spring AOP 的解析机制**：Spring 会解析切点表达式并基于参数类型进行匹配

## 处理可能的冲突情况

如果你确实有多个同名的 `Log` 注解（在不同的包中），你需要使用完全限定名来区分它们：

```java
// 假设有两个同名的 Log 注解
// com.companyA.Log 和 com.companyB.Log

// 只匹配 companyA 的 Log 注解
@Before("@annotation(com.companyA.Log) && @annotation(logAnnotation)")
public void logBeforeA(JoinPoint joinPoint, com.companyA.Log logAnnotation) {
    // 处理 companyA 的 Log 注解
}

// 只匹配 companyB 的 Log 注解
@Before("@annotation(com.companyB.Log) && @annotation(logAnnotation)")
public void logBeforeB(JoinPoint joinPoint, com.companyB.Log logAnnotation) {
    // 处理 companyB 的 Log 注解
}
```

## 最佳实践

1. **使用完全限定名**：在切点表达式中使用注解的完全限定名，避免歧义
2. **保持注解名称唯一**：在项目范围内保持注解名称的唯一性
3. **使用有意义的包名**：将注解放在有明确意义的包中，如 `com.yourcompany.logging`
4. **文档化**：为自定义注解提供清晰的文档，说明其用途和行为

## 总结

要确保只匹配名为 `Log` 的特定注解，最安全的方法是：

1. 在切点表达式中使用注解的完全限定名
2. 确保方法参数的类型是你想要匹配的特定注解类型
3. 避免在项目中使用相同名称的注解，或者使用完全限定名来区分它们

这样，你就可以精确地控制哪些注解会被你的切面拦截，避免意外的匹配行为。